{
  
    
        "post0": {
            "title": "Title",
            "content": ". UK PV Generation Analysis using Prophet . I&#39;ve finally decided to start putting out some blog posts, so to distract from the emptiness of my site I thought I&#39;d post some analysis I did one weekend last summer. Having spent last year working as an analyst at an energy firm, I took an interest in forecasting and analysing trends in energy prices, generation and demand across the UK. Solar PV is a big growth area at the moment with the push to reduce dependancy on fossil fuels, and the Sheffield Solar team at The University of Sheffield have a great API which contains a ton of up to date data on how much PV is being produced across the country. . More information the API is available here and documentation is available here. . First off, some necessary imports and defining the API URL. . import requests import datetime as dt import pandas as pd import matplotlib.pyplot as plt from fbprophet import Prophet API_URL = &quot;https://api0.solar.sheffield.ac.uk/pvlive/v2&quot; . pes in the API query represents the region of the UK. There are 14 primary distribution network operators (DNOs)* in the UK numbered 10 to 23; the 0 in this query represents the entirety of the UK. In reality, there are also other, smaller independent operators (IDNOs). . Using the requests package, we can fetch the data we need from the API. . start_date = &#39;2013-01-01&#39; end_date = dt.date.today().strftime(&quot;%Y-%m-%d&quot;) query_str = (&quot;/pes/0?start=&quot; + start_date + &quot;T00:00:00&amp;end=&quot; + end_date + &quot;T00:00:00&amp;data_format=json&quot;) url = API_URL + query_str response = requests.get(url, headers={&#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Accept&#39;: &#39;application/json&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;}) api_response = response.json() . The first step now we have the data is to convert datetime strings to Pandas timestamps and create a DataFrame in the format required by the Prophet package (i.e. the &#39;ds&#39; column which mimics the index). . def time_str_to_ts(time_str): ts = pd.Timestamp(dt.datetime.strptime(time_str, &quot;%Y-%m-%dT%H:%M:%SZ&quot;)) return ts api_data = api_response[&#39;data&#39;] timestamps = [time_str_to_ts(x[1]) for x in api_data] ts_index = pd.DatetimeIndex(timestamps) generation_mw = [x[2] for x in api_data] df = pd.DataFrame(generation_mw, columns=[&#39;y&#39;], index=ts_index) df = df.resample(&#39;D&#39;).mean() df[&#39;ds&#39;] = df.index df.head() . y ds . 2013-01-01 120.963284 | 2013-01-01 | . 2013-01-02 13.910261 | 2013-01-02 | . 2013-01-03 22.677375 | 2013-01-03 | . 2013-01-04 39.192457 | 2013-01-04 | . 2013-01-05 35.655815 | 2013-01-05 | . Now we have the data in the right format, we can use Prophet. Prophet comes from the Facebook Core Data Science team, and like the other packages coming out of Facebook recently (fastText &amp; PyTorch), it&#39;s pretty good. It abstracts away a lot of the complexities of time series analysis and has a lot of useful features, and whilst this does reduce the control you have over the model compared to say, an ARIMA model which you&#39;ve created with specific parameters, it does tend to serve as a good jumping off point for further analysis. . We can fit the Prophet model to our data, factoring in seasonality, as well as fluctuations due to holidays; perhaps some installations may be turned off during these periods and won&#39;t be generating? Seems unlikely but by specifying this we can at least account for the possibility. . m = Prophet(yearly_seasonality=True, seasonality_mode=&#39;multiplicative&#39;) m.add_country_holidays(country_name=&#39;UK&#39;) m.fit(df) future = m.make_future_dataframe(periods=188, freq=&quot;D&quot;) forecast = m.predict(future) . INFO:fbprophet:Disabling daily seasonality. Run prophet with daily_seasonality=True to override this. . Now we can put together a nice visualisation which shows how rapidly PV generation has grown over the past few years, as well as a six month ahead forecast with confidence intervals. . fig = m.plot(forecast) fig.set_size_inches(22, 7) ax = fig.gca() ax.set_xlabel(&#39;Date&#39;) ax.set_ylabel(&#39;Mean Daily Generation (MW)&#39;) ax.set_title(&#39;UK PV Generation Forecast&#39;) plt.show() . We can also break down the components, to see the year on year trend (increasing, but flattening out), fluctuations due to holidays and also which days of the week and year have the highest generation. Obviously the &#39;day of week&#39; plot here is irrelevant but the day of year plot is a nice visualisation of how PV generation varies over the calendar year. . fig_comp = m.plot_components(forecast) .",
            "url": "https://tomcdonald.github.io/blog/2020/05/19/UK-PV-Generation-Analysis-with-Prophet.html",
            "relUrl": "/2020/05/19/UK-PV-Generation-Analysis-with-Prophet.html",
            "date": " • May 19, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "The University of Sheffield . PhD in Probabilistic Deep Learning (Sept. 2020 - | MSc Data Analytics (2019 - 2020) | BSc Physics (2015 - 2018) | . This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://tomcdonald.github.io/blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://tomcdonald.github.io/blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}